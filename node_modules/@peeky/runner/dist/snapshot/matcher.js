// @TODO prop matchers
import { readSnapshots } from './read.js';
import { format } from './format.js';
import { currentTest } from '../runtime/global-context.js';
import { generateSnapshotId, generateSnapshotTitle } from './util.js';
import { writeSnapshots } from './write.js';
import { basename } from 'pathe';
export class SnapshotMatcher {
    ctx;
    existingSnapshots;
    failedSnapshots;
    passedSnapshots;
    newSnapshots;
    processedSnapshots;
    currentTest;
    currentIndex;
    plugins = []; // @TODO serializer plugins
    titleMap;
    async start(ctx) {
        this.ctx = ctx;
        this.existingSnapshots = await readSnapshots(this.ctx.options.entry);
        this.titleMap = {};
        this.failedSnapshots = [];
        this.passedSnapshots = [];
        this.newSnapshots = [];
        this.processedSnapshots = [];
    }
    toMatchSnapshot(received, propertiesMatchers, hint) {
        if (!currentTest) {
            throw new Error(`toMatchSnapshot can't be called outside of a test`);
        }
        if (typeof propertiesMatchers !== 'object') {
            hint = propertiesMatchers;
        }
        if (this.currentTest !== currentTest) {
            this.currentTest = currentTest;
            this.currentIndex = 1;
        }
        else {
            this.currentIndex++;
        }
        const testFile = this.ctx.options.entry;
        const formattedReceived = `\n${format(received, this.plugins)}\n`;
        const snapshotTitle = generateSnapshotTitle(this.titleMap, hint);
        let processedSnapshot;
        const existingSnapshot = processedSnapshot = this.existingSnapshots.find(s => s.title === snapshotTitle);
        if (existingSnapshot) {
            existingSnapshot.visited = true;
            if (existingSnapshot.content !== formattedReceived) {
                existingSnapshot.newContent = formattedReceived;
                const error = existingSnapshot.error = new Error(`Snapshot '${snapshotTitle}' mismatch`);
                error.matcherResult = {
                    expected: existingSnapshot.content,
                    actual: formattedReceived,
                };
                // Stack
                const stackLines = error.stack.split('\n');
                const stackFileLine = stackLines.find(l => l.includes(basename(testFile)));
                error.stack = [stackLines[0], stackFileLine].filter(Boolean).join('\n');
                this.failedSnapshots.push(existingSnapshot);
                currentTest.failedSnapshots++;
            }
            else {
                this.passedSnapshots.push(existingSnapshot);
            }
        }
        else {
            this.newSnapshots.push(processedSnapshot = {
                id: generateSnapshotId(testFile, snapshotTitle),
                title: snapshotTitle,
                testFile,
                content: formattedReceived,
            });
        }
        this.processedSnapshots.push(processedSnapshot);
        currentTest.snapshots.push(processedSnapshot);
        return {
            message: () => '',
            pass: true,
        };
    }
    async end(updateSnapshots) {
        await writeSnapshots(this.ctx.options.entry, this.processedSnapshots, updateSnapshots);
        return {
            failedSnapshots: this.failedSnapshots,
            passedSnapshots: this.passedSnapshots,
            newSnapshots: this.newSnapshots,
        };
    }
}
