interface StartOfSourceMap {
    file?: string;
    sourceRoot?: string;
}
interface RawSourceMap extends StartOfSourceMap {
    version: string;
    sources: string[];
    names: string[];
    sourcesContent?: string[];
    mappings: string;
}
interface FetchResult {
    code?: string;
    externalize?: string;
    map?: RawSourceMap;
}
declare type FetchFunction = (id: string) => Promise<FetchResult>;
interface ModuleCache {
    promise?: Promise<any>;
    exports?: any;
    code?: string;
}
interface ViteNodeRunnerOptions {
    fetchModule: FetchFunction;
    root: string;
    base?: string;
    moduleCache?: Map<string, ModuleCache>;
    interopDefault?: boolean;
    requestStubs?: Record<string, any>;
}

declare const DEFAULT_REQUEST_STUBS: {
    '/@vite/client': {
        injectQuery: (id: string) => string;
        createHotContext(): {
            accept: () => void;
            prune: () => void;
        };
        updateStyle(): void;
    };
};
declare class ViteNodeRunner {
    options: ViteNodeRunnerOptions;
    root: string;
    moduleCache: Map<string, ModuleCache>;
    constructor(options: ViteNodeRunnerOptions);
    executeFile(file: string): Promise<any>;
    executeId(id: string): Promise<any>;
    cachedRequest(rawId: string, callstack: string[]): Promise<any>;
    directRequest(id: string, fsPath: string, callstack: string[]): Promise<any>;
    prepareContext(context: Record<string, any>): Record<string, any>;
    setCache(id: string, mod: Partial<ModuleCache>): void;
    /**
     * Define if a module should be interop-ed
     * This function mostly for the ability to override by subclass
     */
    shouldInterop(path: string, mod: any): boolean;
    /**
     * Import a module and interop it
     */
    interopedImport(path: string): Promise<any>;
    hasNestedDefault(target: any): any;
}

export { DEFAULT_REQUEST_STUBS, ViteNodeRunner };
